using System;
using System.Linq;

namespace Lorite.GetStartedWithCSharp.P6M03ImplementExceptionHandling {

    public static class Program {

        public static void Main() {
            // Runtime errors in a C# application are managed using a mechanism called exceptions.
            // Exceptions provide a structured, uniform, and type-safe way of handling both system level and application-level error conditions. Exceptions are generated by the .NET runtime or by the code in an application.
            // Common scenarios that may require exception handling include user input, data processing, file I/O operations, database operations, and network communication.
            // Exception handling in C# is implemented using try, catch, and finally keywords. Each keyword has an associated code block that serves a specific purpose.
            // Exceptions are represented as types and derived from the System.Exception class in .NET. Exceptions contain information that identifies the type of exception, and properties that provide additional details.
            // When an exception occurs, the .NET runtime searches for the nearest catch clause that can handle it. The search starts with the method where the exception was thrown, and moves down the call stack if necessary.

            try {
                // Step 1: code execution begins
                try {
                    // Step 2: an exception occurs here
                } finally {
                    // Step 4: the system executes the finally code block associated with the try statement where the exception occurred
                }
            } catch { // Step 3: the system finds a catch clause that can handle the exception
            // Step 5: the system transfers control to the first line of the catch code block
            }

            // Compiler-generated exceptions
            // The .NET runtime throws an exception when an operation fails.
            // The exception type is dependent on the code that causes the exception.
            // Your application should catch runtime exceptions.
            // Some examples of compiler-generated exceptions are: System.ArgumentException, System.ArgumentNullException, System.ArgumentOutOfRangeException, System.DivideByZeroException, System.FormatException,
            // System.IndexOutOfRangeException, System.InvalidCastException, System.InvalidOperationException, System.IO.IOException, System.NotImplementedException, System.NullReferenceException,
            // System.OutOfMemoryException, System.OverflowException, System.StackOverflowException, System.TypeInitializationException, System.TypeLoadException, System.TypeUnloadedException, System.UnauthorizedAccessException

            // Example
            double float1 = 3000.0;
            double float2 = 0.0;
            int number1 = 3000;
            int number2 = 0;
            try {
                Console.WriteLine(float1 / float2);
                Console.WriteLine(number1 / number2);
            } catch (DivideByZeroException) {
                Console.WriteLine("Error: Division by zero is not allowed.");
            } catch (Exception ex) {
                Console.WriteLine($"An error occurred: {ex.Message}");
            } finally {
                Console.WriteLine("Exit program");
            }

            // the check keyword in C# is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.
            // If an overflow occurs within a checked context, an OverflowException is thrown.

            // Catch separate exception types in a code block
            string[] inputValues = new string[]{"three", "9999999999", "0", "2" };
            foreach (string inputValue in inputValues) {
                int numValue = 0;
                try {
                    numValue = int.Parse(inputValue);
                } catch (FormatException) {
                    Console.WriteLine("Invalid readResult. Please enter a valid number.");
                } catch (OverflowException) {
                    Console.WriteLine("The number you entered is too large or too small.");
                } catch(Exception ex) {
                    Console.WriteLine(ex.Message);
                }
            }

            // Exercise
            checked {
                try {
                    int num1 = int.MaxValue;
                    int num2 = int.MaxValue;
                    int result = num1 + num2;
                    Console.WriteLine("Result: " + result);
                }
                catch (OverflowException ex) {
                    Console.WriteLine("Error: The number is too large to be represented as an integer. " + ex.Message);
                }
            }

            try {
                string? str = null;
                int length = str.Length;
                Console.WriteLine("String Length: " + length);
            }
            catch (NullReferenceException ex) {
                Console.WriteLine("Error: The reference is null. " + ex.Message);
            }

            try {
                int[] numbers = new int[5];
                numbers[5] = 10;
                Console.WriteLine("Number at index 5: " + numbers[5]);
            } catch (IndexOutOfRangeException ex) {
                Console.WriteLine("Error: Index out of range. " + ex.Message);
            }

            try {
                int num3 = 10;
                int num4 = 0;
                int result2 = num3 / num4;
                Console.WriteLine("Result: " + result2);
            } catch (DivideByZeroException ex) {
                Console.WriteLine("Error: Cannot divide by zero. " + ex.Message);
            }

            Console.WriteLine("Exiting program.");


        }

    }

}